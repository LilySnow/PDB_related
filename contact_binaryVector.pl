#!/usr/bin/env perl
#===============================================================================
#
#        Li Xue (me.lixue@gmail.com)
#        02/26/2017 04:50:20 PM
#        Utrecht University
#
#  DESCRIPTION: Given a pdb file and cutoff, generate interface as binary vectors: 01110000
#
#       OUTPUT:
#          >A|A:B
#          01100000
#          >B|B:A
#          00001100
#
#   NOTE: only CA-CA interfaces are supported in this version.
#
#===============================================================================

use strict;
use warnings;
use utf8;
use File::Basename;

our %one2three = (
    'A'=>'ALA' ,
    'B'=>'ASX' ,
    'C'=>'CYS' ,
    'D'=>'ASP' ,
    'E'=>'GLU' ,
    'F'=>'PHE' ,
    'G'=>'GLY' ,
    'H'=>'HIS' ,
    'I'=>'ILE' ,
    'J'=>'XLE' ,
    'K'=>'LYS' ,
    'L'=>'LEU' ,
    'M'=>'MET' ,
    'N'=>'ASN' ,
    'O'=>'PYL' ,
    'P'=>'PRO' ,
    'Q'=>'GLN' ,
    'R'=>'ARG' ,
    'S'=>'SER' ,
    'T'=>'THR' ,
    'U'=>'SEC' ,
    'V'=>'VAL' ,
    'W'=>'TRP' ,
    'X'=>'XAA' ,
    'Y'=>'TYR' ,
    'Z'=>'GLX' ,
);


our %three2one = (
    'ALA' => 'A',
    'ASX' => 'B',
    'CYS' => 'C',
    'ASP' => 'D',
    'GLU' => 'E',
    'PHE' => 'F',
    'GLY' => 'G',
    'HIS' => 'H',
    'ILE' => 'I',
    'XLE' => 'J',
    'LYS' => 'K',
    'LEU' => 'L',
    'MET' => 'M',
    'ASN' => 'N',
    'PYL' => 'O',
    'PRO' => 'P',
    'GLN' => 'Q',
    'ARG' => 'R',
    'SER' => 'S',
    'THR' => 'T',
    'SEC' => 'U',
    'VAL' => 'V',
    'TRP' => 'W',
    'XAA' => 'X',
    'TYR' => 'Y',
    'GLX' => 'Z',
    'CYM' => 'C',
    'CSP' => 'C',
    'CYF' => 'C',
    'CFE' => 'C',
    'NEP' => 'H',
    'ALY' => 'K',
    'M3L' => 'K',
    'SEP' => 'S',
    'TOP' => 'T',
    'TYP' => 'Y',
    'PTR' => 'Y',
    'TYS' => 'Y',
    'HYP' => 'P',
    'PTR' => 'Y',
);



my $pdbFL = shift @ARGV;
my $CACA_cutoff = shift @ARGV;

if (! defined $CACA_cutoff){
    print "\nUsage: contact_binaryVector.pl pdbFL CACA_cutoff\n";
    exit 0;
}
my $dirname = dirname($pdbFL);
my $name = basename($pdbFL, '.pdb');

my $contactFL = "$dirname/$name.contact";
system("contact-chainID_allAtoms $pdbFL 15 > $contactFL.tmp") == 0 or die ("Failed:$!");
system("egrep \'CA.+CA\' $contactFL.tmp |awk \'\$NF <= $CACA_cutoff\' > $contactFL ") ==0  or die ("Failed:$!");

#--- $name.contact:
#
#           ARG A     13     NE     ASP B    387     CG     4.87515
#           ARG A     13     NE     ASP B    387     OD2    3.90175
#

my $atomResNumFL = "$dirname/$name.atomResNum";
system("PDB2AtomResNum.pl $pdbFL > $atomResNumFL" ) ==0 or die("FAILED: $!");

#--- $name.atomResNum:
#
#    #chainID,seqnum,aa,atomResnum
#    A,1,G,3
#    A,2,I,4

my ($interacting_chainIDs, $contacts ) = &readContactFL($contactFL);
my ($atomResNums,$seq) = &readAtomResNumFL($atomResNumFL);

print "# generated by $0 $pdbFL $CACA_cutoff\n\n";
foreach my $chnPair (@$interacting_chainIDs){
    # $chnPair = ('A:B')
    #
    my ($chn1, $chn2) = split(/:/, $chnPair);

    #-- print interface vector for $chn1|$chn1:$chn2
    print ">$chn1|$chn1:$chn2\n";
    my $seq_line = join( '', @{$seq->{$chn1}} );
    print "$seq_line\n";
    my $int = &IntVector($contacts->{"$chn1:$chn2"}, $atomResNums->{$chn1});
    print "$int\n";

    #-- print interface vector for $chn2|$chn2:$chn1
    print ">$chn2|$chn2:$chn1\n";
    $seq_line = join( '', @{$seq->{$chn2} } );
    print "$seq_line\n";
    $int = &IntVector($contacts->{"$chn2:$chn1"}, $atomResNums->{$chn2});
    print "$int\n";
}


unlink $contactFL;
unlink "$contactFL.tmp";
unlink $atomResNumFL;

#-------------------------------------------

sub IntVector{
    my $contacts = shift @_;
    #$contacts->{"$chn1:$chn2"}->{"$aa1\_$chn1\_$atomResNum1"}->{"$aa2\_$chn2\_$atomResNum2"} = $dist;
    my @atomResNums = @{shift @_};
    my @int;

    foreach my $atomResNum (@atomResNums){
        #-- $atomResNum = 'ARG_A_33'

        if (defined $contacts->{$atomResNum}){
            push @int, 1;
        }
        else{
            push @int, 0;
        }
    }
    my $line = join('', @int);
    return $line;

}
sub readAtomResNumFL{

#    #chainID,seqnum,aa,atomResnum
#    A,1,G,3
#    A,2,I,4

    our %one2three;

     my $atomResNumFL = shift @_;
     my $seq;
     my $atomResNums;

     my $flag =0;
     open (INPUT, "<$atomResNumFL") or die ("Cannot open $atomResNumFL:$!");
     while(<INPUT>){
         s/[\n\r]//gm;

         if (/^\w+,/){
             $flag =1;
             my ($chnID, $seqNum, $aa_1Lett, $atomResNum) = split(/,/, $_);
             my $aa_3Lett = $one2three{$aa_1Lett};
             push @{$atomResNums->{$chnID}}, "$aa_3Lett\_$chnID\_$atomResNum";
             push @{$seq->{$chnID} }, $aa_1Lett;
         }
     }
     close (INPUT);

     if ($flag == 0 ){
         die ("Nothing read from $atomResNumFL:$!");
     }


     return ($atomResNums, $seq);
}

sub readContactFL{

#--- $name.contact:
#
#           ARG A     13     NE     ASP B    387     CG     4.87515
#           ARG A     13     NE     ASP B    387     OD2    3.90175
     my $contactFL = shift @_;
     my @interacting_chainIDs;
     my $contacts;

     open(INPUT,"<$contactFL") or die ("Cannot open $contactFL:$!");
     while(<INPUT>){
         s/[\n\r]//mg;

         if (/^\w+\s+/){
#           ARG A     13     NE     ASP B    387     CG     4.87515
             my ($aa1, $chn1, $atomResNum1, $atom1, $aa2, $chn2, $atomResNum2, $atom2, $dist) = split(/\s+/, $_);

             if (!defined $dist || $dist !~/^[\d\.\-\e]+$/i){
                 die("Format of contact file is wrong. Check $contactFL:$!");
             }
             push @interacting_chainIDs, "$chn1:$chn2";
             $contacts->{"$chn1:$chn2"}->{"$aa1\_$chn1\_$atomResNum1"}->{"$aa2\_$chn2\_$atomResNum2"} = $dist;
             $contacts->{"$chn2:$chn1"}->{"$aa2\_$chn2\_$atomResNum2"}->{"$aa1\_$chn1\_$atomResNum1"} = $dist;
         }
     }
     close (INPUT);

     if (! @interacting_chainIDs){
         die("Nothing read from $contactFL:$!");
     }
     @interacting_chainIDs = &unique(@interacting_chainIDs);

     return (\@interacting_chainIDs, $contacts)
}

#------------
sub unique {
    my @a = @_;
    my %seen;
    @seen{@a} = 1 x scalar(@a);
    @a = keys(%seen);
    return @a;
}

